{"version":3,"sources":["AuthenticationProvider.min__d6b9bcc2bfcb024de483.js","./src/ui/AuthenticationProvider/AuthenticationProvider.ts"],"names":["webpackJsonpCoveo__temporary","236","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","_window","AuthenticationProvider","ID","storage","SafeLocalStorage","ComponentOptions","initComponentOptions","Assert","exists","name","handlers","window","redirectCount","bind","onRootElement","QueryEvents","buildingCallOptions","handleBuildingCallOptions","queryError","handleQueryError","InitializationEvents","nuke","handleNuke","afterComponentsInitialization","args","onAfterComponentsInitialization","SettingsEvents","settingsPopulateMenu","menuData","push","text","l","caption","className","onOpen","authenticateWithProvider","svgIcon","SVGIcons","icons","dropdownAuthenticate","svgIconClassName","_this","getHandshakeTokenFromUrl","hash","getHashAfterAdjustingForAngular","token","HashUtils","getValue","getHash","isAngularHash","slice","get","indexOf","enumerable","configurable","handshakeInProgress","waitForHandshakeToFinish","then","loadAccessTokenFromStorage","defer","handshakeToken","shouldExchangeHandshakeToken","enableHandshakeInProgressFlag","promise","exchangeHandshakeToken","storeAccessToken","removeHandshakeTokenFromUrl","catch","e","logger","error","finally","disableHandshakeInProgressFlag","tabId","$$","getAttribute","activeTabId","QUERY_STATE_ATTRIBUTES","T","accessToken","getAccessTokenFromStorage","queryController","getEndpoint","setItem","accessTokenStorageKey","organizationId","Promise","resolve","interval","setInterval","clearInterval","handshakeEntry","handshakeTokenParamName","entries","substr","split","newHash","filter","param","join","adjustedHash","history","replaceState","updateToken","getItem","authentication","shouldClearToken","shouldClearTokenFollowingErrorEvent","removeItem","location","reload","missingAuthError","isMissingAuthentication","provider","exceptions","useIFrame","authenticateWithIFrame","redirectToAuthenticationProvider","info","href","getAuthenticationProviderUriForRedirect","modalbox","iframe","src","getAuthenticationProviderUriForIFrame","el","showIFrame","createPopupForVisibleIFrame","createPopupForWaitMessage","handler","createHandler","one","detach","close","executeQuery","_","each","off","popup","DomUtils","getBasicLoadingAnimation","hide","document","body","appendChild","ModalBox","open","title","sizeMod","searchInterface","modalContainer","addClass","getAuthenticationProviderUri","undefined","doExport","exportGlobally","buildStringOption","postProcessing","buildBooleanOption","defaultValue","alias","depend","Component","Initialization","registerAutoCreateComponent","598"],"mappings":"AAAAA,8BAA8B,KAExBC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAEA,IAAIC,GAAaC,MAAQA,KAAKD,WAAc,WACxC,GAAIE,GAAgBC,OAAOC,iBACpBC,uBAA2BC,QAAS,SAAUC,EAAGC,GAAKD,EAAEF,UAAYG,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIC,KAAKD,GAAOA,EAAEE,eAAeD,KAAIF,EAAEE,GAAKD,EAAEC,IACzE,OAAO,UAAUF,EAAGC,GAEhB,QAASG,KAAOV,KAAKW,YAAcL,EADnCL,EAAcK,EAAGC,GAEjBD,EAAEM,UAAkB,OAANL,EAAaL,OAAOW,OAAON,IAAMG,EAAGE,UAAYL,EAAEK,UAAW,GAAIF,OAGvFR,QAAOY,eAAejB,EAAS,cAAgBkB,OAAO,GCjBtD,YACA,OACA,OACA,QAEA,QACA,QAEA,QACA,OACA,OACA,OACA,QAEA,OACA,MACA,OACA,aACA,QACA,QACA,QAqBA,cAwEE,WACSC,EACAC,EACPC,EACOC,OAFA,KAAAF,SAFT,OAME,YAAMD,EAASI,EAAuBC,GAAIH,IAAS,IDpC/C,OC+BG,GAAAF,UACA,EAAAC,UAEA,EAAAE,UAbD,EAAAG,QAAU,GAAI,GAAAC,iBAiBpB,EAAKN,QAAU,EAAAO,iBAAiBC,qBAAqBT,EAASI,EAAwBH,GAEtF,EAAAS,OAAOC,OAAO,EAAKV,QAAQW,MAE3B,EAAKC,YAEL,EAAKV,QAAU,EAAKA,SAAWW,OAC/B,EAAKC,cAAgB,EAErB,EAAKC,KAAKC,cAAc,EAAAC,YAAYC,oBAAqB,EAAKC,2BAC9D,EAAKJ,KAAKC,cAAc,EAAAC,YAAYG,WAAY,EAAKC,kBACrD,EAAKN,KAAKC,cAAc,EAAAM,qBAAqBC,KAAM,EAAKC,YACxD,EAAKT,KAAKC,cAAc,EAAAM,qBAAqBG,8BAA+B,SAACC,GAC3E,SAAKC,gCAAgCD,KAGvC,EAAKX,KAAKC,cAAc,EAAAY,eAAeC,qBAAsB,SAACH,GAC5DA,EAAKI,SAASC,MACZC,KAAM,EAAAC,EAAE,iBAAkB,EAAKjC,QAAQkC,SACvCC,UAAW,gCACXC,OAAQ,WAAM,SAAKC,4BACnBC,QAAS,EAAAC,SAASC,MAAMC,qBACxBC,iBAAkB,wCD5DXC,ECiSf,MA3U4C,QA2GlC,YAAAC,yBAAR,WACE,GAAMC,GAAO9D,KAAK+D,kCACZC,EAAQ,EAAAC,UAAUC,SAhII,kBAgI8BJ,EAC1D,OAAwB,gBAAVE,GAAqBA,EAAQ,IAGrC,YAAAD,gCAAR,WACE,GAAMD,GAAO,EAAAG,UAAUE,SACvB,OAAOnE,MAAKoE,cAAgB,IAAIN,EAAKO,MAAM,GAAOP,GAGpD,sBAAY,6BDhENQ,ICgEN,WAEE,MAAiC,KADjB,EAAAL,UAAUE,UACXI,QAAQ,OD9DnBC,YAAY,EACZC,cAAc,ICgEZ,YAAA7B,gCAAR,SAAwCD,GAAxC,UACE,IAAIvB,EAAuBsD,oBAAqB,CAC9C,GAAM,GAAU1E,KAAK2E,2BAA2BC,KAAK,WAAM,SAAKC,8BAGhE,YADAlC,GAAKmC,MAAM9B,KAAK,GAIlB,GAAM+B,GAAiB/E,KAAK6D,0BAE5B,KAAKkB,EACH,MAAO/E,MAAK6E,4BAGd,IAAK7E,KAAKgF,6BAAV,CAIAhF,KAAKiF,+BAEL,IAAMC,GAAUlF,KAAKmF,uBAAuBJ,GACzCH,KAAK,SAAAZ,GAAS,SAAKoB,iBAAiBpB,KACpCY,KAAK,WAAM,SAAKS,gCAChBT,KAAK,WAAM,SAAKC,+BAChBS,MAAM,SAAAC,GAAK,SAAKC,OAAOC,MAAMF,KAC7BG,QAAQ,WAAM,SAAKC,kCAEtBhD,GAAKmC,MAAM9B,KAAKkC,KAGlB,sBAAY,4CDpENZ,ICoEN,WACE,GAAMsB,GAAQ,EAAAC,GAAG7F,KAAKgB,SAAS8E,aAAa,YACtChC,EAAO,EAAAG,UAAUE,UACjB4B,EAAc,EAAA9B,UAAUC,SAAS,EAAA8B,uBAAuBC,EAAGnC,EACjE,QAAQ8B,GAASA,IAAUG,GDlEvBvB,YAAY,EACZC,cAAc,ICoEZ,YAAAU,uBAAR,SAA+BJ,GAC7B,GAAMmB,GAAclG,KAAKmG,4BACnBlF,EAAUiF,GAAgBnB,eAAc,EAAEmB,YAAW,IAAOnB,eAAc,EAChF,OAAO/E,MAAKoG,gBAAgBC,cAAclB,uBAAuBlE,IAG3D,YAAAmE,iBAAR,SAAyBc,GACvBlG,KAAKsB,QAAQgF,QAAQtG,KAAKuG,sBAAuBL,IAGnD,sBAAY,qCDnEN5B,ICmEN,WAEE,MAAO,oCADC,gEAAAkC,gBDhEJhC,YAAY,EACZC,cAAc,ICmEZ,YAAAE,yBAAR,WACE,MAAO,IAAI8B,SAAQ,SAAAC,GACjB,GAAMC,GAAWC,YAAY,WACvBxF,EAAuBsD,sBAI3BmC,cAAcF,GACdD,MACC,QAIC,YAAAzB,8BAAR,WACE7D,EAAuBsD,qBAAsB,GAGvC,YAAAiB,+BAAR,WACEvE,EAAuBsD,qBAAsB,GAGvC,YAAAW,4BAAR,WACE,GACMvB,GAAO9D,KAAK+D,kCACZC,EAAQhE,KAAK6D,2BACbiD,EAAoBC,mBAA2B/C,EAE/CgD,EAAUlD,EAAKmD,OAAO,GAAGC,MALb,KAMZC,EAAUH,EAAQI,OAAO,SAAAC,GAAS,MAAAA,KAAUP,IAAgBQ,KANhD,KAOZC,EAAevH,KAAKoE,cAAgB,IAAI+C,EAAYA,CAE1DnH,MAAKmB,QAAQqG,QAAQC,aAAa,KAAM,GAAI,IAAIF,IAG1C,YAAA1C,2BAAR,WACE,GAAMb,GAAQhE,KAAKmG,2BACnBnC,IAAShE,KAAKoG,gBAAgBC,cAAcH,YAAYwB,YAAY1D,IAG9D,YAAAmC,0BAAR,WACE,MAAOnG,MAAKsB,QAAQqG,QAAQ3H,KAAKuG,wBAG3B,YAAAnE,0BAAR,SAAkCO,GAChCA,EAAK1B,QAAQ2G,eAAe5E,KAAKhD,KAAKiB,QAAQW,OAGxC,YAAAU,iBAAR,SAAyBK,GACvB,GAAMqB,GAAQhE,KAAKmG,4BACb0B,EAAmB7H,KAAK8H,oCAAoCnF,EAElE,IAAIqB,GAAS6D,EAGX,MAFA7H,MAAKsB,QAAQyG,WAAW/H,KAAKuG,2BAC7BvG,MAAKmB,QAAQ6G,SAASC,QAIxB,IAAIC,GAA+CvF,EAAK8C,KAGtDyC,GAAiBC,yBACjBD,EAAiBE,WAAapI,KAAKiB,QAAQW,MAC3C5B,KAAK+B,cAAgB,IACG,IAAxB/B,KAAK+B,iBAEH/B,KAAK+B,cACP/B,KAAKsD,6BAELtD,KAAKwF,OAAOC,MAAM,0GAClBzF,KAAK+B,eAAiB,IAIlB,YAAA+F,oCAAR,SAA4CnF,GAC1C,GAAM0F,IAAc,wBAAyB,wBAAyB,0CAChE5C,EAAQ9C,EAAK8C,MAAM7D,IACzB,QAAsC,IAA/ByG,EAAW9D,QAAQkB,IAGpB,YAAAnC,yBAAR,WACEtD,KAAKiB,QAAQqH,UAAYtI,KAAKuI,yBAA2BvI,KAAKwI,oCAGxD,YAAAA,iCAAR,WACExI,KAAKwF,OAAOiD,KAAK,0CAA0CzI,KAAKiB,QAAQW,MACxE5B,KAAKmB,QAAQ6G,SAASU,KAAO1I,KAAK2I,2CAG5B,YAAAJ,uBAAR,WACEvI,KAAKwF,OAAOiD,KAAK,wDAAwDzI,KAAKiB,QAAQW,KAEtF,IAIIgH,GAJAC,EAAS,EAAAhD,GAAG,UACdiD,IAAK9I,KAAK+I,0CACTC,EAGHJ,GAAW5I,KAAKiB,QAAQgI,WAAajJ,KAAKkJ,4BAA4BL,GAAU7I,KAAKmJ,0BAA0BN,EAE/G,IAAIO,GAAUpJ,KAAKqJ,cAAcT,EAAUC,EAC3C,GAAAhD,GAAQ7F,KAAKmB,SAASmI,IAAI,UAAWF,GACrCpJ,KAAK6B,SAASmB,KAAKoG,IAGb,YAAAC,cAAR,SAAsBT,EAAmCC,GAAzD,UACE,OAAO,YACL,EAAAhD,GAAGgD,GAAQU,SACX,EAAK/D,OAAOiD,KAAK,mCAAmC,EAAKxH,QAAQW,KAAI,qBACrEgH,EAASY,QACT,EAAKpD,gBAAgBqD,iBAIjB,YAAAhH,WAAR,qBACEiH,GAAEC,KAAK3J,KAAK6B,SAAU,SAAAuH,GAAW,SAAAvD,GAAQ,EAAK1E,SAASyI,IAAI,UAAWR,MAGhE,YAAAD,0BAAR,SAAkCN,GAChC,GAAIgB,GAAQ,EAAAhE,GACV,OAEEzC,UAAW,0CAEb,EAAA0G,SAASC,4BACTf,EAUF,OARA,GAAAnD,GAAGgD,GAAQmB,OACXC,SAASC,KAAKC,YAAYtB,GAE1B,EAAAuB,SAASC,KAAKR,GACZS,MAAO,EAAApH,EAAE,iBAAkBlD,KAAKiB,QAAQkC,SACxCoH,QAAS,QACTL,KAAMlK,KAAKwK,gBAAgBvJ,QAAQwJ,iBAE9B,EAAAL,UAGD,YAAAlB,4BAAR,SAAoCL,GAClC,EAAAhD,GAAGgD,GAAQ6B,SAAS,8BACpB,IAAIb,GAAQ,EAAAhE,GAAG,SAAWgD,GAAQG,EAQlC,OANA,GAAAoB,SAASC,KAAKR,GACZS,MAAO,EAAApH,EAAE,iBAAkBlD,KAAKiB,QAAQkC,SACxCC,UAAW,6BACXmH,QAAS,MACTL,KAAMlK,KAAKwK,gBAAgBvJ,QAAQwJ,iBAE9B,EAAAL,UAGD,YAAAzB,wCAAR,WACE,MAAO3I,MAAKoG,gBAAgBC,cAAcsE,6BAA6B3K,KAAKiB,QAAQW,KAAM5B,KAAKmB,QAAQ6G,SAASU,SAAMkC,KAGhH,YAAA7B,sCAAR,WACE,MAAO/I,MAAKoG,gBAAgBC,cAAcsE,6BAA6B3K,KAAKiB,QAAQW,SAAMgJ,GAAW,YAxUhG,EAAAvJ,GAAK,yBACL,EAAAqD,qBAAsB,EAEtB,EAAAmG,SAAW,WAChB,EAAAC,gBACE1J,uBAAwBA,KAQrB,EAAAH,SAMLW,KAAM,EAAAJ,iBAAiBuJ,oBAQvB5H,QAAS,EAAA3B,iBAAiBuJ,mBAAoBC,eAAgB,SAACjK,EAAOE,GAAY,MAAAF,IAASE,EAAQW,QAWnG0G,UAAW,EAAA9G,iBAAiByJ,oBAC1BC,cAAc,EACdC,OAAQ,eAaVlC,WAAY,EAAAzH,iBAAiByJ,oBAC3BC,cAAc,EACdC,OAAQ,cACRC,OAAQ,eAkRd,GA3U4C,EAAAC,UAA/B,GAAAjK,yBA6Ub,EAAAkK,eAAeC,4BAA4BnK,IDrCrCoK,IACA,SAAU5L,EAAQC","file":"AuthenticationProvider.min__d6b9bcc2bfcb024de483.js","sourcesContent":["webpackJsonpCoveo__temporary([77],{\n\n/***/ 236:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Component_1 = __webpack_require__(7);\nvar ComponentOptions_1 = __webpack_require__(8);\nvar Assert_1 = __webpack_require__(5);\nvar QueryEvents_1 = __webpack_require__(11);\nvar InitializationEvents_1 = __webpack_require__(17);\nvar SettingsEvents_1 = __webpack_require__(55);\nvar DomUtils_1 = __webpack_require__(95);\nvar Dom_1 = __webpack_require__(1);\nvar Initialization_1 = __webpack_require__(2);\nvar Strings_1 = __webpack_require__(6);\nvar ExternalModulesShim_1 = __webpack_require__(26);\nvar _ = __webpack_require__(0);\nvar GlobalExports_1 = __webpack_require__(3);\n__webpack_require__(598);\nvar SVGIcons_1 = __webpack_require__(12);\nvar HashUtils_1 = __webpack_require__(42);\nvar QueryStateModel_1 = __webpack_require__(13);\nvar LocalStorageUtils_1 = __webpack_require__(41);\nvar handshakeTokenParamName = 'handshake_token';\n/**\n * The `AuthenticationProvider` component makes it possible to execute queries with an identity that the end user\n * can obtain using an authentication provider configured on the Coveo REST Search API\n * (see [Claims Authentication](https://docs.coveo.com/en/113/)).\n *\n * When necessary, this component handles redirecting the browser to the address that starts the authentication process.\n *\n * You can use the `data-tab` attribute to enable the `AuthenticationProvider` component only for the tabs of your\n * search interface that require authentication (see the [`Tab`]{@link Tab} component).\n */\nvar AuthenticationProvider = /** @class */ (function (_super) {\n    __extends(AuthenticationProvider, _super);\n    /**\n     * Creates a new `AuthenticationProvider` component.\n     * @param element The HTMLElement on which to instantiate the component.\n     * @param options The options for the `AuthenticationProvider` component.\n     * @param bindings The bindings that the component requires to function normally. If not set, these will be\n     * automatically resolved (with a slower execution time).\n     */\n    function AuthenticationProvider(element, options, bindings, _window) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this, element, AuthenticationProvider.ID, bindings) || this;\n        _this.element = element;\n        _this.options = options;\n        _this._window = _window;\n        _this.storage = new LocalStorageUtils_1.SafeLocalStorage();\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, AuthenticationProvider, options);\n        Assert_1.Assert.exists(_this.options.name);\n        _this.handlers = [];\n        _this._window = _this._window || window;\n        _this.redirectCount = 0;\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.buildingCallOptions, _this.handleBuildingCallOptions);\n        _this.bind.onRootElement(QueryEvents_1.QueryEvents.queryError, _this.handleQueryError);\n        _this.bind.onRootElement(InitializationEvents_1.InitializationEvents.nuke, _this.handleNuke);\n        _this.bind.onRootElement(InitializationEvents_1.InitializationEvents.afterComponentsInitialization, function (args) {\n            return _this.onAfterComponentsInitialization(args);\n        });\n        _this.bind.onRootElement(SettingsEvents_1.SettingsEvents.settingsPopulateMenu, function (args) {\n            args.menuData.push({\n                text: Strings_1.l('Reauthenticate', _this.options.caption),\n                className: 'coveo-authentication-provider',\n                onOpen: function () { return _this.authenticateWithProvider(); },\n                svgIcon: SVGIcons_1.SVGIcons.icons.dropdownAuthenticate,\n                svgIconClassName: 'coveo-authentication-provider-svg'\n            });\n        });\n        return _this;\n    }\n    AuthenticationProvider.prototype.getHandshakeTokenFromUrl = function () {\n        var hash = this.getHashAfterAdjustingForAngular();\n        var token = HashUtils_1.HashUtils.getValue(handshakeTokenParamName, hash);\n        return typeof token === 'string' ? token : '';\n    };\n    AuthenticationProvider.prototype.getHashAfterAdjustingForAngular = function () {\n        var hash = HashUtils_1.HashUtils.getHash();\n        return this.isAngularHash ? \"#\" + hash.slice(2) : hash;\n    };\n    Object.defineProperty(AuthenticationProvider.prototype, \"isAngularHash\", {\n        get: function () {\n            var rawHash = HashUtils_1.HashUtils.getHash();\n            return rawHash.indexOf('#/') === 0;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AuthenticationProvider.prototype.onAfterComponentsInitialization = function (args) {\n        var _this = this;\n        if (AuthenticationProvider.handshakeInProgress) {\n            var promise_1 = this.waitForHandshakeToFinish().then(function () { return _this.loadAccessTokenFromStorage(); });\n            args.defer.push(promise_1);\n            return;\n        }\n        var handshakeToken = this.getHandshakeTokenFromUrl();\n        if (!handshakeToken) {\n            return this.loadAccessTokenFromStorage();\n        }\n        if (!this.shouldExchangeHandshakeToken) {\n            return;\n        }\n        this.enableHandshakeInProgressFlag();\n        var promise = this.exchangeHandshakeToken(handshakeToken)\n            .then(function (token) { return _this.storeAccessToken(token); })\n            .then(function () { return _this.removeHandshakeTokenFromUrl(); })\n            .then(function () { return _this.loadAccessTokenFromStorage(); })\n            .catch(function (e) { return _this.logger.error(e); })\n            .finally(function () { return _this.disableHandshakeInProgressFlag(); });\n        args.defer.push(promise);\n    };\n    Object.defineProperty(AuthenticationProvider.prototype, \"shouldExchangeHandshakeToken\", {\n        get: function () {\n            var tabId = Dom_1.$$(this.element).getAttribute('data-tab');\n            var hash = HashUtils_1.HashUtils.getHash();\n            var activeTabId = HashUtils_1.HashUtils.getValue(QueryStateModel_1.QUERY_STATE_ATTRIBUTES.T, hash);\n            return !tabId || tabId === activeTabId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AuthenticationProvider.prototype.exchangeHandshakeToken = function (handshakeToken) {\n        var accessToken = this.getAccessTokenFromStorage();\n        var options = accessToken ? { handshakeToken: handshakeToken, accessToken: accessToken } : { handshakeToken: handshakeToken };\n        return this.queryController.getEndpoint().exchangeHandshakeToken(options);\n    };\n    AuthenticationProvider.prototype.storeAccessToken = function (accessToken) {\n        this.storage.setItem(this.accessTokenStorageKey, accessToken);\n    };\n    Object.defineProperty(AuthenticationProvider.prototype, \"accessTokenStorageKey\", {\n        get: function () {\n            var organizationId = this.queryController.getEndpoint().options.queryStringArguments.organizationId;\n            return \"coveo-auth-provider-access-token-\" + organizationId;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AuthenticationProvider.prototype.waitForHandshakeToFinish = function () {\n        return new Promise(function (resolve) {\n            var interval = setInterval(function () {\n                if (AuthenticationProvider.handshakeInProgress) {\n                    return;\n                }\n                clearInterval(interval);\n                resolve();\n            }, 100);\n        });\n    };\n    AuthenticationProvider.prototype.enableHandshakeInProgressFlag = function () {\n        AuthenticationProvider.handshakeInProgress = true;\n    };\n    AuthenticationProvider.prototype.disableHandshakeInProgressFlag = function () {\n        AuthenticationProvider.handshakeInProgress = false;\n    };\n    AuthenticationProvider.prototype.removeHandshakeTokenFromUrl = function () {\n        var delimiter = \"&\";\n        var hash = this.getHashAfterAdjustingForAngular();\n        var token = this.getHandshakeTokenFromUrl();\n        var handshakeEntry = handshakeTokenParamName + \"=\" + token;\n        var entries = hash.substr(1).split(delimiter);\n        var newHash = entries.filter(function (param) { return param !== handshakeEntry; }).join(delimiter);\n        var adjustedHash = this.isAngularHash ? \"/\" + newHash : newHash;\n        this._window.history.replaceState(null, '', \"#\" + adjustedHash);\n    };\n    AuthenticationProvider.prototype.loadAccessTokenFromStorage = function () {\n        var token = this.getAccessTokenFromStorage();\n        token && this.queryController.getEndpoint().accessToken.updateToken(token);\n    };\n    AuthenticationProvider.prototype.getAccessTokenFromStorage = function () {\n        return this.storage.getItem(this.accessTokenStorageKey);\n    };\n    AuthenticationProvider.prototype.handleBuildingCallOptions = function (args) {\n        args.options.authentication.push(this.options.name);\n    };\n    AuthenticationProvider.prototype.handleQueryError = function (args) {\n        var token = this.getAccessTokenFromStorage();\n        var shouldClearToken = this.shouldClearTokenFollowingErrorEvent(args);\n        if (token && shouldClearToken) {\n            this.storage.removeItem(this.accessTokenStorageKey);\n            this._window.location.reload();\n            return;\n        }\n        var missingAuthError = args.error;\n        if (missingAuthError.isMissingAuthentication &&\n            missingAuthError.provider === this.options.name &&\n            this.redirectCount < 2 &&\n            this.redirectCount !== -1) {\n            ++this.redirectCount;\n            this.authenticateWithProvider();\n        }\n        else {\n            this.logger.error('The AuthenticationProvider is in a redirect loop. This may be due to a back-end configuration problem.');\n            this.redirectCount = -1;\n        }\n    };\n    AuthenticationProvider.prototype.shouldClearTokenFollowingErrorEvent = function (args) {\n        var exceptions = ['InvalidTokenException', 'ExpiredTokenException', 'InvalidAuthenticationProviderException'];\n        var error = args.error.name;\n        return exceptions.indexOf(error) !== -1;\n    };\n    AuthenticationProvider.prototype.authenticateWithProvider = function () {\n        this.options.useIFrame ? this.authenticateWithIFrame() : this.redirectToAuthenticationProvider();\n    };\n    AuthenticationProvider.prototype.redirectToAuthenticationProvider = function () {\n        this.logger.info(\"Redirecting to authentication provider \" + this.options.name);\n        this._window.location.href = this.getAuthenticationProviderUriForRedirect();\n    };\n    AuthenticationProvider.prototype.authenticateWithIFrame = function () {\n        this.logger.info(\"Using iframe to retrieve authentication for provider \" + this.options.name);\n        var iframe = Dom_1.$$('iframe', {\n            src: this.getAuthenticationProviderUriForIFrame()\n        }).el;\n        var modalbox;\n        modalbox = this.options.showIFrame ? this.createPopupForVisibleIFrame(iframe) : this.createPopupForWaitMessage(iframe);\n        var handler = this.createHandler(modalbox, iframe);\n        Dom_1.$$(this._window).one('message', handler);\n        this.handlers.push(handler);\n    };\n    AuthenticationProvider.prototype.createHandler = function (modalbox, iframe) {\n        var _this = this;\n        return function () {\n            Dom_1.$$(iframe).detach();\n            _this.logger.info(\"Got authentication for provider \" + _this.options.name + \"; retrying query.\");\n            modalbox.close();\n            _this.queryController.executeQuery();\n        };\n    };\n    AuthenticationProvider.prototype.handleNuke = function () {\n        var _this = this;\n        _.each(this.handlers, function (handler) { return Dom_1.$$(_this._window).off('message', handler); });\n    };\n    AuthenticationProvider.prototype.createPopupForWaitMessage = function (iframe) {\n        var popup = Dom_1.$$('div', {\n            className: 'coveo-waiting-for-authentication-popup'\n        }, DomUtils_1.DomUtils.getBasicLoadingAnimation()).el;\n        Dom_1.$$(iframe).hide();\n        document.body.appendChild(iframe);\n        ExternalModulesShim_1.ModalBox.open(popup, {\n            title: Strings_1.l('Authenticating', this.options.caption),\n            sizeMod: 'small',\n            body: this.searchInterface.options.modalContainer\n        });\n        return ExternalModulesShim_1.ModalBox;\n    };\n    AuthenticationProvider.prototype.createPopupForVisibleIFrame = function (iframe) {\n        Dom_1.$$(iframe).addClass('coveo-authentication-iframe');\n        var popup = Dom_1.$$('div', {}, iframe).el;\n        ExternalModulesShim_1.ModalBox.open(popup, {\n            title: Strings_1.l('Authenticating', this.options.caption),\n            className: 'coveo-authentication-popup',\n            sizeMod: 'big',\n            body: this.searchInterface.options.modalContainer\n        });\n        return ExternalModulesShim_1.ModalBox;\n    };\n    AuthenticationProvider.prototype.getAuthenticationProviderUriForRedirect = function () {\n        return this.queryController.getEndpoint().getAuthenticationProviderUri(this.options.name, this._window.location.href, undefined);\n    };\n    AuthenticationProvider.prototype.getAuthenticationProviderUriForIFrame = function () {\n        return this.queryController.getEndpoint().getAuthenticationProviderUri(this.options.name, undefined, 'success');\n    };\n    AuthenticationProvider.ID = 'AuthenticationProvider';\n    AuthenticationProvider.handshakeInProgress = false;\n    AuthenticationProvider.doExport = function () {\n        GlobalExports_1.exportGlobally({\n            AuthenticationProvider: AuthenticationProvider\n        });\n    };\n    /**\n     * The options for the component.\n     * @componentOptions\n     */\n    AuthenticationProvider.options = {\n        /**\n         * Specifies the name of the authentication provider.\n         *\n         * See [SAML Authentication](https://docs.coveo.com/en/91/).\n         */\n        name: ComponentOptions_1.ComponentOptions.buildStringOption(),\n        /**\n         * Specifies the display name of the authentication provider. This is the name that you want to appear in the user\n         * interface when the end user is logging in.\n         *\n         * Default value is the [`name`]{@link AuthenticationProvider.options.name} option value.\n         */\n        caption: ComponentOptions_1.ComponentOptions.buildStringOption({ postProcessing: function (value, options) { return value || options.name; } }),\n        /**\n         * Specifies whether to use an `<iframe>` to host the chain of redirection that make up the authentication\n         * process.\n         *\n         * Using an `<iframe>` prevents leaving the search page as part of the authentication process. However, some login\n         * providers refuse to load in an `<iframe>`.\n         *\n         * Default value is `false`.\n         */\n        useIFrame: ComponentOptions_1.ComponentOptions.buildBooleanOption({\n            defaultValue: false,\n            alias: ['useIframe']\n        }),\n        /**\n         * If the [`useIFrame`]{@link AuthenticationProvider.options.useIFrame} option is `true`, specifies whether to make\n         * the authentication `<iframe>` visible to the user (inside a popup).\n         *\n         * When the underlying authentication provider requires no user interaction (for example, when a user authenticates\n         * using Windows authentication along with SharePoint claims), setting this option to `false` reduces the visual\n         * impact of the authentication process.\n         *\n         * Default value is `true`.\n         */\n        showIFrame: ComponentOptions_1.ComponentOptions.buildBooleanOption({\n            defaultValue: true,\n            alias: ['showIframe'],\n            depend: 'useIFrame'\n        })\n    };\n    return AuthenticationProvider;\n}(Component_1.Component));\nexports.AuthenticationProvider = AuthenticationProvider;\nInitialization_1.Initialization.registerAutoCreateComponent(AuthenticationProvider);\n\n\n/***/ }),\n\n/***/ 598:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// AuthenticationProvider.min__d6b9bcc2bfcb024de483.js","import { Component } from '../Base/Component';\nimport { ComponentOptions } from '../Base/ComponentOptions';\nimport { Assert } from '../../misc/Assert';\nimport { QueryEvents, IBuildingCallOptionsEventArgs, IQueryErrorEventArgs } from '../../events/QueryEvents';\nimport { IComponentBindings } from '../Base/ComponentBindings';\nimport { IInitializationEventArgs, InitializationEvents } from '../../events/InitializationEvents';\nimport { SettingsEvents } from '../../events/SettingsEvents';\nimport { ISettingsPopulateMenuArgs } from '../Settings/Settings';\nimport { DomUtils } from '../../utils/DomUtils';\nimport { $$ } from '../../utils/Dom';\nimport { Initialization } from '../Base/Initialization';\nimport { l } from '../../strings/Strings';\nimport { ModalBox } from '../../ExternalModulesShim';\nimport { MissingAuthenticationError } from '../../rest/MissingAuthenticationError';\nimport * as _ from 'underscore';\nimport { exportGlobally } from '../../GlobalExports';\nimport 'styling/_AuthenticationProvider';\nimport { SVGIcons } from '../../utils/SVGIcons';\nimport { HashUtils } from '../../utils/HashUtils';\nimport { QUERY_STATE_ATTRIBUTES } from '../../models/QueryStateModel';\nimport { SafeLocalStorage } from '../../utils/LocalStorageUtils';\n\nconst handshakeTokenParamName = 'handshake_token';\n\nexport interface IAuthenticationProviderOptions {\n  name?: string;\n  caption?: string;\n  useIFrame?: boolean;\n  showIFrame?: boolean;\n}\n\n/**\n * The `AuthenticationProvider` component makes it possible to execute queries with an identity that the end user\n * can obtain using an authentication provider configured on the Coveo REST Search API\n * (see [Claims Authentication](https://docs.coveo.com/en/113/)).\n *\n * When necessary, this component handles redirecting the browser to the address that starts the authentication process.\n *\n * You can use the `data-tab` attribute to enable the `AuthenticationProvider` component only for the tabs of your\n * search interface that require authentication (see the [`Tab`]{@link Tab} component).\n */\nexport class AuthenticationProvider extends Component {\n  static ID = 'AuthenticationProvider';\n  static handshakeInProgress = false;\n\n  static doExport = () => {\n    exportGlobally({\n      AuthenticationProvider: AuthenticationProvider\n    });\n  };\n\n  /**\n   * The options for the component.\n   * @componentOptions\n   */\n  static options: IAuthenticationProviderOptions = {\n    /**\n     * Specifies the name of the authentication provider.\n     *\n     * See [SAML Authentication](https://docs.coveo.com/en/91/).\n     */\n    name: ComponentOptions.buildStringOption(),\n\n    /**\n     * Specifies the display name of the authentication provider. This is the name that you want to appear in the user\n     * interface when the end user is logging in.\n     *\n     * Default value is the [`name`]{@link AuthenticationProvider.options.name} option value.\n     */\n    caption: ComponentOptions.buildStringOption({ postProcessing: (value, options) => value || options.name }),\n\n    /**\n     * Specifies whether to use an `<iframe>` to host the chain of redirection that make up the authentication\n     * process.\n     *\n     * Using an `<iframe>` prevents leaving the search page as part of the authentication process. However, some login\n     * providers refuse to load in an `<iframe>`.\n     *\n     * Default value is `false`.\n     */\n    useIFrame: ComponentOptions.buildBooleanOption({\n      defaultValue: false,\n      alias: ['useIframe']\n    }),\n\n    /**\n     * If the [`useIFrame`]{@link AuthenticationProvider.options.useIFrame} option is `true`, specifies whether to make\n     * the authentication `<iframe>` visible to the user (inside a popup).\n     *\n     * When the underlying authentication provider requires no user interaction (for example, when a user authenticates\n     * using Windows authentication along with SharePoint claims), setting this option to `false` reduces the visual\n     * impact of the authentication process.\n     *\n     * Default value is `true`.\n     */\n    showIFrame: ComponentOptions.buildBooleanOption({\n      defaultValue: true,\n      alias: ['showIframe'],\n      depend: 'useIFrame'\n    })\n  };\n\n  private handlers: ((...args: any[]) => void)[];\n  private redirectCount: number;\n  private storage = new SafeLocalStorage();\n\n  /**\n   * Creates a new `AuthenticationProvider` component.\n   * @param element The HTMLElement on which to instantiate the component.\n   * @param options The options for the `AuthenticationProvider` component.\n   * @param bindings The bindings that the component requires to function normally. If not set, these will be\n   * automatically resolved (with a slower execution time).\n   */\n  constructor(\n    public element: HTMLElement,\n    public options: IAuthenticationProviderOptions = {},\n    bindings?: IComponentBindings,\n    public _window?: Window\n  ) {\n    super(element, AuthenticationProvider.ID, bindings);\n\n    this.options = ComponentOptions.initComponentOptions(element, AuthenticationProvider, options);\n\n    Assert.exists(this.options.name);\n\n    this.handlers = [];\n\n    this._window = this._window || window;\n    this.redirectCount = 0;\n\n    this.bind.onRootElement(QueryEvents.buildingCallOptions, this.handleBuildingCallOptions);\n    this.bind.onRootElement(QueryEvents.queryError, this.handleQueryError);\n    this.bind.onRootElement(InitializationEvents.nuke, this.handleNuke);\n    this.bind.onRootElement(InitializationEvents.afterComponentsInitialization, (args: IInitializationEventArgs) =>\n      this.onAfterComponentsInitialization(args)\n    );\n\n    this.bind.onRootElement(SettingsEvents.settingsPopulateMenu, (args: ISettingsPopulateMenuArgs) => {\n      args.menuData.push({\n        text: l('Reauthenticate', this.options.caption),\n        className: 'coveo-authentication-provider',\n        onOpen: () => this.authenticateWithProvider(),\n        svgIcon: SVGIcons.icons.dropdownAuthenticate,\n        svgIconClassName: 'coveo-authentication-provider-svg'\n      });\n    });\n  }\n\n  private getHandshakeTokenFromUrl() {\n    const hash = this.getHashAfterAdjustingForAngular();\n    const token = HashUtils.getValue(handshakeTokenParamName, hash);\n    return typeof token === 'string' ? token : '';\n  }\n\n  private getHashAfterAdjustingForAngular() {\n    const hash = HashUtils.getHash();\n    return this.isAngularHash ? `#${hash.slice(2)}` : hash;\n  }\n\n  private get isAngularHash() {\n    const rawHash = HashUtils.getHash();\n    return rawHash.indexOf('#/') === 0;\n  }\n\n  private onAfterComponentsInitialization(args: IInitializationEventArgs) {\n    if (AuthenticationProvider.handshakeInProgress) {\n      const promise = this.waitForHandshakeToFinish().then(() => this.loadAccessTokenFromStorage());\n\n      args.defer.push(promise);\n      return;\n    }\n\n    const handshakeToken = this.getHandshakeTokenFromUrl();\n\n    if (!handshakeToken) {\n      return this.loadAccessTokenFromStorage();\n    }\n\n    if (!this.shouldExchangeHandshakeToken) {\n      return;\n    }\n\n    this.enableHandshakeInProgressFlag();\n\n    const promise = this.exchangeHandshakeToken(handshakeToken)\n      .then(token => this.storeAccessToken(token))\n      .then(() => this.removeHandshakeTokenFromUrl())\n      .then(() => this.loadAccessTokenFromStorage())\n      .catch(e => this.logger.error(e))\n      .finally(() => this.disableHandshakeInProgressFlag());\n\n    args.defer.push(promise);\n  }\n\n  private get shouldExchangeHandshakeToken() {\n    const tabId = $$(this.element).getAttribute('data-tab');\n    const hash = HashUtils.getHash();\n    const activeTabId = HashUtils.getValue(QUERY_STATE_ATTRIBUTES.T, hash);\n    return !tabId || tabId === activeTabId;\n  }\n\n  private exchangeHandshakeToken(handshakeToken: string) {\n    const accessToken = this.getAccessTokenFromStorage();\n    const options = accessToken ? { handshakeToken, accessToken } : { handshakeToken };\n    return this.queryController.getEndpoint().exchangeHandshakeToken(options);\n  }\n\n  private storeAccessToken(accessToken: string) {\n    this.storage.setItem(this.accessTokenStorageKey, accessToken);\n  }\n\n  private get accessTokenStorageKey() {\n    const { organizationId } = this.queryController.getEndpoint().options.queryStringArguments;\n    return `coveo-auth-provider-access-token-${organizationId}`;\n  }\n\n  private waitForHandshakeToFinish() {\n    return new Promise(resolve => {\n      const interval = setInterval(() => {\n        if (AuthenticationProvider.handshakeInProgress) {\n          return;\n        }\n\n        clearInterval(interval);\n        resolve();\n      }, 100);\n    });\n  }\n\n  private enableHandshakeInProgressFlag() {\n    AuthenticationProvider.handshakeInProgress = true;\n  }\n\n  private disableHandshakeInProgressFlag() {\n    AuthenticationProvider.handshakeInProgress = false;\n  }\n\n  private removeHandshakeTokenFromUrl() {\n    const delimiter = `&`;\n    const hash = this.getHashAfterAdjustingForAngular();\n    const token = this.getHandshakeTokenFromUrl();\n    const handshakeEntry = `${handshakeTokenParamName}=${token}`;\n\n    const entries = hash.substr(1).split(delimiter);\n    const newHash = entries.filter(param => param !== handshakeEntry).join(delimiter);\n    const adjustedHash = this.isAngularHash ? `/${newHash}` : newHash;\n\n    this._window.history.replaceState(null, '', `#${adjustedHash}`);\n  }\n\n  private loadAccessTokenFromStorage() {\n    const token = this.getAccessTokenFromStorage();\n    token && this.queryController.getEndpoint().accessToken.updateToken(token);\n  }\n\n  private getAccessTokenFromStorage() {\n    return this.storage.getItem(this.accessTokenStorageKey);\n  }\n\n  private handleBuildingCallOptions(args: IBuildingCallOptionsEventArgs) {\n    args.options.authentication.push(this.options.name);\n  }\n\n  private handleQueryError(args: IQueryErrorEventArgs) {\n    const token = this.getAccessTokenFromStorage();\n    const shouldClearToken = this.shouldClearTokenFollowingErrorEvent(args);\n\n    if (token && shouldClearToken) {\n      this.storage.removeItem(this.accessTokenStorageKey);\n      this._window.location.reload();\n      return;\n    }\n\n    let missingAuthError = <MissingAuthenticationError>args.error;\n\n    if (\n      missingAuthError.isMissingAuthentication &&\n      missingAuthError.provider === this.options.name &&\n      this.redirectCount < 2 &&\n      this.redirectCount !== -1\n    ) {\n      ++this.redirectCount;\n      this.authenticateWithProvider();\n    } else {\n      this.logger.error('The AuthenticationProvider is in a redirect loop. This may be due to a back-end configuration problem.');\n      this.redirectCount = -1;\n    }\n  }\n\n  private shouldClearTokenFollowingErrorEvent(args: IQueryErrorEventArgs) {\n    const exceptions = ['InvalidTokenException', 'ExpiredTokenException', 'InvalidAuthenticationProviderException'];\n    const error = args.error.name;\n    return exceptions.indexOf(error) !== -1;\n  }\n\n  private authenticateWithProvider() {\n    this.options.useIFrame ? this.authenticateWithIFrame() : this.redirectToAuthenticationProvider();\n  }\n\n  private redirectToAuthenticationProvider() {\n    this.logger.info(`Redirecting to authentication provider ${this.options.name}`);\n    this._window.location.href = this.getAuthenticationProviderUriForRedirect();\n  }\n\n  private authenticateWithIFrame() {\n    this.logger.info(`Using iframe to retrieve authentication for provider ${this.options.name}`);\n\n    let iframe = $$('iframe', {\n      src: this.getAuthenticationProviderUriForIFrame()\n    }).el;\n\n    let modalbox: Coveo.ModalBox.ModalBox;\n    modalbox = this.options.showIFrame ? this.createPopupForVisibleIFrame(iframe) : this.createPopupForWaitMessage(iframe);\n\n    let handler = this.createHandler(modalbox, iframe);\n    $$(<any>this._window).one('message', handler);\n    this.handlers.push(handler);\n  }\n\n  private createHandler(modalbox: Coveo.ModalBox.ModalBox, iframe: HTMLElement): () => void {\n    return () => {\n      $$(iframe).detach();\n      this.logger.info(`Got authentication for provider ${this.options.name}; retrying query.`);\n      modalbox.close();\n      this.queryController.executeQuery();\n    };\n  }\n\n  private handleNuke() {\n    _.each(this.handlers, handler => $$(<any>this._window).off('message', handler));\n  }\n\n  private createPopupForWaitMessage(iframe: HTMLElement): Coveo.ModalBox.ModalBox {\n    let popup = $$(\n      'div',\n      {\n        className: 'coveo-waiting-for-authentication-popup'\n      },\n      DomUtils.getBasicLoadingAnimation()\n    ).el;\n\n    $$(iframe).hide();\n    document.body.appendChild(iframe);\n\n    ModalBox.open(popup, {\n      title: l('Authenticating', this.options.caption),\n      sizeMod: 'small',\n      body: this.searchInterface.options.modalContainer\n    });\n    return ModalBox;\n  }\n\n  private createPopupForVisibleIFrame(iframe: HTMLElement): Coveo.ModalBox.ModalBox {\n    $$(iframe).addClass('coveo-authentication-iframe');\n    let popup = $$('div', {}, iframe).el;\n\n    ModalBox.open(popup, {\n      title: l('Authenticating', this.options.caption),\n      className: 'coveo-authentication-popup',\n      sizeMod: 'big',\n      body: this.searchInterface.options.modalContainer\n    });\n    return ModalBox;\n  }\n\n  private getAuthenticationProviderUriForRedirect(): string {\n    return this.queryController.getEndpoint().getAuthenticationProviderUri(this.options.name, this._window.location.href, undefined);\n  }\n\n  private getAuthenticationProviderUriForIFrame(): string {\n    return this.queryController.getEndpoint().getAuthenticationProviderUri(this.options.name, undefined, 'success');\n  }\n}\n\nInitialization.registerAutoCreateComponent(AuthenticationProvider);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/AuthenticationProvider/AuthenticationProvider.ts"],"sourceRoot":""}