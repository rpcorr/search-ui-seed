{"version":3,"sources":["MissingTerms.min__d6b9bcc2bfcb024de483.js","./src/ui/MissingTerm/MissingTerms.ts"],"names":["webpackJsonpCoveo__temporary","291","module","exports","__webpack_require__","__extends","this","extendStatics","Object","setPrototypeOf","__proto__","Array","d","b","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","value","element","options","bindings","result","MissingTerms","ID","ComponentOptions","initComponentOptions","addMissingTerms","_this","get","absentTerms","attachments","intersectAbsentTerms","childResults","enumerable","configurable","results","intersection","map","absentPhrases","terms","allResultTerms","filter","isMissingPhrase","term","termMatch","queryMatch","push","phrases","phrase","withoutQuotes","slice","phraseMatch","Utils","stringStartsWith","stringEndsWith","stripBreakingCharacters","regex","createWordBoundaryDelimitedRegex","query","queryStateModel","queryToExec","replace","XRegExp","breakingCharacters","exec","addTermForcedToAppear","missingTerms","indexOf","logger","warn","toString","updateTermForcedToAppear","termForcedToAppear","set","length","missingTermElement","buildContainer","hideMissingTermsOverTheNumberOfResults","$$","append","elements","buildCaption","el","buildMissingTerms","forEach","className","caption","validTerms","isValidTerm","validPhrases","isValidPhrase","makeTermClickableIfEnabled","executeNewQuery","missingTerm","queryController","executeQuery","clickable","termElement","type","on","logAnalyticsAddMissingTerm","MissingTermManager","wordBoundary","containsFeaturedResults","allMissingTerms","tagName","numberOfTerms","index","hide","nbMoreResults","showMore","l","showAllHiddenMissingTerms","find","parentNode","removeChild","findAll","show","removeAttribute","isNonBoundaryTerm","every","wordWithBreakpoints","match","word","usageAnalytics","logSearchEvent","analyticsActionCauseList","addMissingTerm","buildBooleanOption","defaultValue","buildLocalizedStringOption","localizedString","buildNumberOption","min","doExport","exportGlobally","Component","Initialization","registerAutoCreateComponent","698"],"mappings":"AAAAA,8BAA8B,KAExBC,IACA,SAAUC,EAAQC,EAASC,GAEjC,YAEA,IAAIC,GAAaC,MAAQA,KAAKD,WAAc,WACxC,GAAIE,GAAgBC,OAAOC,iBACpBC,uBAA2BC,QAAS,SAAUC,EAAGC,GAAKD,EAAEF,UAAYG,IACvE,SAAUD,EAAGC,GAAK,IAAK,GAAIC,KAAKD,GAAOA,EAAEE,eAAeD,KAAIF,EAAEE,GAAKD,EAAEC,IACzE,OAAO,UAAUF,EAAGC,GAEhB,QAASG,KAAOV,KAAKW,YAAcL,EADnCL,EAAcK,EAAGC,GAEjBD,EAAEM,UAAkB,OAANL,EAAaL,OAAOW,OAAON,IAAMG,EAAGE,UAAYL,EAAEK,UAAW,GAAIF,OAGvFR,QAAOY,eAAejB,EAAS,cAAgBkB,OAAO,ICjBtD,MACA,aACA,OAGA,QACA,OAEA,OACA,SACA,SACA,OACA,QAcA,cAgDE,WACSC,EACAC,EACPC,EACOC,GAJT,MAME,YAAMH,EAASI,EAAaC,GAAIH,IAAS,ID9BrC,OCyBG,GAAAF,UACA,EAAAC,UAEA,EAAAE,SAIP,EAAKF,QAAU,EAAAK,iBAAiBC,qBAAqBP,EAASI,EAAcH,GAC5E,EAAKO,kBDjCMC,EC8Pf,MAtRkC,QA4DhC,sBAAY,8BDjCNC,ICiCN,WACE,GAAIC,GAAc3B,KAAKmB,OAAOQ,WAU9B,OARI3B,MAAKmB,OAAOS,cACdD,EAAc3B,KAAK6B,qBAAqBF,EAAa3B,KAAKmB,OAAOS,cAG/D5B,KAAKmB,OAAOW,eACdH,EAAc3B,KAAK6B,qBAAqBF,EAAa3B,KAAKmB,OAAOW,eAG5DH,GDlCHI,YAAY,EACZC,cAAc,ICoCZ,YAAAH,qBAAR,SAA6BF,EAAuBM,GAClD,MAAO,GAAAC,aAAY,cAACP,GAAW,OAAKM,EAAQE,IAAI,SAAAhB,GAAU,MAAAA,GAAOQ,iBAMnE,sBAAW,4BDlCLD,ICkCN,WACE,MAAW1B,MAAK2B,YAAW,OAAK3B,KAAKoC,gBDhCjCL,YAAY,EACZC,cAAc,ICkCpB,sBAAY,2BD/BNN,IC+BN,WAIE,IAAmB,GAJrB,QACQC,KACAU,EAAQrC,KAAKsC,eAAeC,OAAO,SAAAxB,GAAS,OAAC,EAAKyB,gBAAgBzB,KAErD,MAAAsB,EAAA,eAAO,CAArB,GAAMI,GAAI,KACPC,EAAY1C,KAAK2C,WAAWF,EAClCC,IAAaf,EAAYiB,KAAKF,GAGhC,MAAOf,ID7BHI,YAAY,EACZC,cAAc,IC+BpB,sBAAY,6BD5BNN,IC4BN,WAIE,IAAqB,GAJvB,QACQU,KACAS,EAAU7C,KAAKsC,eAAeC,OAAO,SAAAxB,GAAS,SAAKyB,gBAAgBzB,KAEpD,MAAA8B,EAAA,eAAS,CAAzB,GAAMC,GAAM,KACTC,EAAgBD,EAAOE,MAAM,GAAI,GACjCC,EAAcjD,KAAK2C,WAAWI,GAAe,EACnDE,IAAeb,EAAcQ,KAAKK,GAGpC,MAAOb,ID1BHL,YAAY,EACZC,cAAc,IC4BZ,YAAAQ,gBAAR,SAAwBzB,GACtB,MAAO,GAAAmC,MAAMC,iBAAiBpC,EAAO,MAAQ,EAAAmC,MAAME,eAAerC,EAAO,MAGnE,YAAA4B,WAAR,SAAmBF,EAAcY,OAAA,KAAAA,OAAA,EAC/B,IAAMC,GAAQtD,KAAKuD,iCAAiCd,GAC9Ce,EAAgBxD,KAAKyD,gBAAgB/B,IAAI,KAEzCgC,EAAcL,EAA0BG,EAAMG,QAAQC,EAAQ5D,KAAK6D,mBAAoB,MAAO,KAAOL,EACrGrC,EAASmC,EAAMQ,KAAKJ,EAE1B,IAAIvC,EAAQ,CAEV,MAD+BA,GAAO,GAIxC,MAAO,OAOF,YAAA4C,sBAAP,SAA6BtB,GAC3B,IAAyC,IAArCzC,KAAKgE,aAAaC,QAAQxB,GAK5B,WAJAzC,MAAKkE,OAAOC,KACV,+DAA+D1B,EAAI,4BACnE,0BAA0BzC,KAAKgE,aAAaI,WAAU,IAI1DpE,MAAKqE,2BACLrE,KAAKsE,mBAAmB1B,KAAKH,GAC7BzC,KAAKyD,gBAAgBc,IAAI,eAAoBvE,KAAKsE,mBAAkB,UAG9D,YAAAD,yBAAR,WACErE,KAAKsE,mBAAyBtE,KAAKyD,gBAAgB/B,IAAI,gBAAe,SAGhE,YAAAF,gBAAR,qBACE,IAAiC,IAA7BxB,KAAKgE,aAAaQ,OAAtB,CAGA,GAAMC,GAAqBzE,KAAK0E,gBAC5BD,GAAmBD,OAAS,IAC9BxE,KAAK2E,uCAAuCF,GAC5CA,EAAmBtC,IAAI,SAAAnB,GACrB,EAAA4D,GAAG,EAAK5D,SAAS6D,OAAO7D,QAKtB,YAAA0D,eAAR,WACE,GAAMI,KAON,OANAA,GAASlC,KAAK5C,KAAK+E,eAAeC,IAClChF,KAAKiF,oBAAoBC,QAAQ,SAAAzC,GAC3BA,GACFqC,EAASlC,KAAKH,EAAKuC,MAGhBF,GAGD,YAAAC,aAAR,WACE,MAAO,GAAAH,GAAG,QAAUO,UAAW,uBAAyBnF,KAAKiB,QAAQmE,UAG/D,YAAAH,kBAAR,sBACQI,EAAarF,KAAK2B,YAAYY,OAAO,SAAAE,GAAQ,SAAK6C,YAAY7C,KAC9D8C,EAAevF,KAAKoC,cAAcG,OAAO,SAAAO,GAAU,SAAK0C,cAAc1C,EAAQuC,IACpF,OAAWA,GAAU,OAAKE,GAAcpD,IAAI,SAAAM,GAC1C,MAAO,GAAKgD,2BAA2BhD,MAInC,YAAAiD,gBAAR,SAAwBC,OAAA,KAAAA,MAAsB3F,KAAKyD,gBAAgB/B,IAAI,MACrE1B,KAAK4F,gBAAgBC,gBAGf,YAAAJ,2BAAR,SAAmChD,GAAnC,UACE,IAAIzC,KAAKiB,QAAQ6E,UAAW,CAC1B,GAAMC,GAAc,EAAAnB,GAAG,UAAYO,UAAW,qCAAsCa,KAAM,UAAYvD,EAMtG,OALAsD,GAAYE,GAAG,QAAS,WACtB,EAAKlC,sBAAsBtB,GAC3B,EAAKyD,2BAA2BzD,GAChC,EAAKiD,gBAAgBjD,KAEhBsD,EAEP,MAAO,GAAAnB,GAAG,QAAUO,UAAW,sBAAwB1C,IAInD,YAAAc,iCAAR,SAAyCd,GACvC,MAAOmB,GAAW,EAAAuC,mBAAmBC,aAAY,IAAI3D,EAAI,IAAI,EAAA0D,mBAAmBC,aAAgB,OAG1F,YAAAC,wBAAR,SAAgC5D,GAE9B,MADAzC,MAAKqE,4BAC6C,IAA3CrE,KAAKsE,mBAAmBL,QAAQxB,IAGjC,YAAAkC,uCAAR,SAA+CG,GAA/C,WACQwB,EAAkBxB,EAASvC,OAAO,SAAAvB,GACtC,MAA2B,WAApBA,EAAQuF,SAEjB,MAAID,EAAgB9B,QAAUxE,KAAKiB,QAAQuF,eAA3C,CAGA,IAAK,GAAIC,GAAQzG,KAAKiB,QAAQuF,cAAeC,EAAQH,EAAgB9B,OAAQiC,IAC3E,EAAA7B,GAAG0B,EAAgBG,IAAQC,MAE7B,IAAMC,GAAgBL,EAAgB9B,OAASxE,KAAKiB,QAAQuF,cACtDI,EAAW,EAAAhC,GACf,UACEO,UAAW,+CAAgDa,KAAM,UACnE,EAAAa,EAAE,SAAUF,IAGdC,GAASX,GAAG,QAAS,WACnB,EAAKa,8BAEPhC,EAASlC,KAAKgE,EAAS5B,MAGjB,YAAA8B,0BAAR,WACE,GAAMF,GAAW,EAAAhC,GAAG5E,KAAKgB,SAAS+F,KAAK,gCACvCH,GAASI,WAAWC,YAAYL,EAEhC,KAAK,GADCN,GAAkB,EAAA1B,GAAG5E,KAAKgB,SAASkG,QAAQ,uBACxCT,EAAQzG,KAAKiB,QAAQuF,cAAeC,EAAQH,EAAgB9B,OAAQiC,IAC3E,EAAA7B,GAAG0B,EAAgBG,IAAQU,OAC3Bb,EAAgBG,GAAOW,gBAAgB,UAInC,YAAA9B,YAAR,SAAoB7C,GAClB,MAAOzC,MAAKqH,kBAAkB5E,KAAUzC,KAAKqG,wBAAwB5D,IAG/D,YAAA+C,cAAR,SAAsB1C,EAAgBT,GAAtC,UACE,OAAOA,GAAMiF,MAAM,SAAA7E,GAGjB,OAFc,EAAKc,iCAAiCd,GACzBqB,KAAKhB,MAKpC,sBAAY,kCD3CNpB,IC2CN,WACE,MAAO,6BDzCHK,YAAY,EACZC,cAAc,IC2CZ,YAAAqF,kBAAR,SAA0B5E,GAExB,GAAM8E,GAAsB,UAAUvH,KAAK6D,mBAAkB,UACvDP,EAAQM,EAAQ2D,EAAqB,KAG3C,QAFcvH,KAAKyD,gBAAgB/B,IAAI,KACjB8F,MAAMlE,QACbgE,MAAM,SAACG,GACpB,OAA+B,IAAxBA,EAAKxD,QAAQxB,MAIhB,YAAAyD,2BAAR,SAAmCzD,GACjCzC,KAAK0H,eAAeC,eAAsC,EAAAC,yBAAyBC,gBACjFlC,YAAalD,KAlRV,EAAApB,GAAK,eAKL,EAAAJ,SAML6E,UAAW,EAAAxE,iBAAiBwG,oBAAqBC,cAAc,IAM/D3C,QAAS,EAAA9D,iBAAiB0G,4BACxBC,gBAAiB,WAAM,SAAApB,EAAE,cAQ3BL,cAAe,EAAAlF,iBAAiB4G,mBAC9BH,aAAc,EACdI,IAAK,KAIF,EAAAC,SAAW,WAChB,EAAAC,gBACEjH,aAAcA,KAmPpB,GAtRkC,EAAAkH,UAArB,GAAAlH,eAuRb,EAAAmH,eAAeC,4BAA4BpH,IDArCqH,IACA,SAAU7I,EAAQC","file":"MissingTerms.min__d6b9bcc2bfcb024de483.js","sourcesContent":["webpackJsonpCoveo__temporary([69],{\n\n/***/ 291:\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__webpack_require__(698);\nvar Core_1 = __webpack_require__(20);\nvar GlobalExports_1 = __webpack_require__(3);\nvar AnalyticsActionListMeta_1 = __webpack_require__(10);\nvar Component_1 = __webpack_require__(7);\nvar ComponentOptions_1 = __webpack_require__(8);\nvar MissingTermManager_1 = __webpack_require__(204);\nvar XRegExp = __webpack_require__(205);\nvar underscore_1 = __webpack_require__(0);\nvar UtilsModules_1 = __webpack_require__(86);\n/**\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\n * that were not matched by the associated result item.\n *\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\n */\nvar MissingTerms = /** @class */ (function (_super) {\n    __extends(MissingTerms, _super);\n    /**\n     * Creates a new `MissingTerms` component instance.\n     * @param element The element on which to instantiate the component.\n     * @param options The configuration options for the component.\n     * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\n     * @param result The query result item to associate the component with.\n     */\n    function MissingTerms(element, options, bindings, result) {\n        var _this = _super.call(this, element, MissingTerms.ID, bindings) || this;\n        _this.element = element;\n        _this.options = options;\n        _this.result = result;\n        _this.options = ComponentOptions_1.ComponentOptions.initComponentOptions(element, MissingTerms, options);\n        _this.addMissingTerms();\n        return _this;\n    }\n    Object.defineProperty(MissingTerms.prototype, \"allResultTerms\", {\n        get: function () {\n            var absentTerms = this.result.absentTerms;\n            if (this.result.attachments) {\n                absentTerms = this.intersectAbsentTerms(absentTerms, this.result.attachments);\n            }\n            if (this.result.childResults) {\n                absentTerms = this.intersectAbsentTerms(absentTerms, this.result.childResults);\n            }\n            return absentTerms;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MissingTerms.prototype.intersectAbsentTerms = function (absentTerms, results) {\n        return underscore_1.intersection.apply(void 0, [absentTerms].concat(results.map(function (result) { return result.absentTerms; })));\n    };\n    Object.defineProperty(MissingTerms.prototype, \"missingTerms\", {\n        /**\n         * Returns all original basic query expression terms and phrases that were not matched by the result item the component instance is associated with.\n         */\n        get: function () {\n            return this.absentTerms.concat(this.absentPhrases);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MissingTerms.prototype, \"absentTerms\", {\n        get: function () {\n            var _this = this;\n            var absentTerms = [];\n            var terms = this.allResultTerms.filter(function (value) { return !_this.isMissingPhrase(value); });\n            for (var _i = 0, terms_1 = terms; _i < terms_1.length; _i++) {\n                var term = terms_1[_i];\n                var termMatch = this.queryMatch(term);\n                termMatch && absentTerms.push(termMatch);\n            }\n            return absentTerms;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(MissingTerms.prototype, \"absentPhrases\", {\n        get: function () {\n            var _this = this;\n            var absentPhrases = [];\n            var phrases = this.allResultTerms.filter(function (value) { return _this.isMissingPhrase(value); });\n            for (var _i = 0, phrases_1 = phrases; _i < phrases_1.length; _i++) {\n                var phrase = phrases_1[_i];\n                var withoutQuotes = phrase.slice(1, -1);\n                var phraseMatch = this.queryMatch(withoutQuotes, true);\n                phraseMatch && absentPhrases.push(phraseMatch);\n            }\n            return absentPhrases;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MissingTerms.prototype.isMissingPhrase = function (value) {\n        return UtilsModules_1.Utils.stringStartsWith(value, '\"') && UtilsModules_1.Utils.stringEndsWith(value, '\"');\n    };\n    MissingTerms.prototype.queryMatch = function (term, stripBreakingCharacters) {\n        if (stripBreakingCharacters === void 0) { stripBreakingCharacters = false; }\n        var regex = this.createWordBoundaryDelimitedRegex(term);\n        var query = this.queryStateModel.get('q');\n        // Mimics the query received by the index\n        var queryToExec = stripBreakingCharacters ? query.replace(XRegExp(this.breakingCharacters, 'gi'), ' ') : query;\n        var result = regex.exec(queryToExec);\n        if (result) {\n            var originalKeywordInQuery = result[4];\n            return originalKeywordInQuery;\n        }\n        return null;\n    };\n    /**\n     * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\n     * @param term The term to add to the advanced query expression.\n     */\n    MissingTerms.prototype.addTermForcedToAppear = function (term) {\n        if (this.missingTerms.indexOf(term) === -1) {\n            this.logger.warn(\"Method execution aborted because the term to inject in aq (\\\"\" + term + \"\\\") is not a missing term.\", \"Allowed missing terms: \" + this.missingTerms.toString() + \".\");\n            return;\n        }\n        this.updateTermForcedToAppear();\n        this.termForcedToAppear.push(term);\n        this.queryStateModel.set('missingTerms', this.termForcedToAppear.slice());\n    };\n    MissingTerms.prototype.updateTermForcedToAppear = function () {\n        this.termForcedToAppear = this.queryStateModel.get('missingTerms').slice();\n    };\n    MissingTerms.prototype.addMissingTerms = function () {\n        var _this = this;\n        if (this.missingTerms.length === 0) {\n            return;\n        }\n        var missingTermElement = this.buildContainer();\n        if (missingTermElement.length > 1) {\n            this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\n            missingTermElement.map(function (element) {\n                Core_1.$$(_this.element).append(element);\n            });\n        }\n    };\n    MissingTerms.prototype.buildContainer = function () {\n        var elements = [];\n        elements.push(this.buildCaption().el);\n        this.buildMissingTerms().forEach(function (term) {\n            if (term) {\n                elements.push(term.el);\n            }\n        });\n        return elements;\n    };\n    MissingTerms.prototype.buildCaption = function () {\n        return Core_1.$$('span', { className: 'coveo-field-caption' }, this.options.caption);\n    };\n    MissingTerms.prototype.buildMissingTerms = function () {\n        var _this = this;\n        var validTerms = this.absentTerms.filter(function (term) { return _this.isValidTerm(term); });\n        var validPhrases = this.absentPhrases.filter(function (phrase) { return _this.isValidPhrase(phrase, validTerms); });\n        return validTerms.concat(validPhrases).map(function (term) {\n            return _this.makeTermClickableIfEnabled(term);\n        });\n    };\n    MissingTerms.prototype.executeNewQuery = function (missingTerm) {\n        if (missingTerm === void 0) { missingTerm = this.queryStateModel.get('q'); }\n        this.queryController.executeQuery();\n    };\n    MissingTerms.prototype.makeTermClickableIfEnabled = function (term) {\n        var _this = this;\n        if (this.options.clickable) {\n            var termElement = Core_1.$$('button', { className: 'coveo-missing-term coveo-clickable', type: 'button' }, term);\n            termElement.on('click', function () {\n                _this.addTermForcedToAppear(term);\n                _this.logAnalyticsAddMissingTerm(term);\n                _this.executeNewQuery(term);\n            });\n            return termElement;\n        }\n        else {\n            return Core_1.$$('span', { className: 'coveo-missing-term' }, term);\n        }\n    };\n    MissingTerms.prototype.createWordBoundaryDelimitedRegex = function (term) {\n        return XRegExp(MissingTermManager_1.MissingTermManager.wordBoundary + \"(\" + term + \")\" + MissingTermManager_1.MissingTermManager.wordBoundary, 'gi');\n    };\n    MissingTerms.prototype.containsFeaturedResults = function (term) {\n        this.updateTermForcedToAppear();\n        return this.termForcedToAppear.indexOf(term) !== -1;\n    };\n    MissingTerms.prototype.hideMissingTermsOverTheNumberOfResults = function (elements) {\n        var _this = this;\n        var allMissingTerms = elements.filter(function (element) {\n            return element.tagName === 'BUTTON';\n        });\n        if (allMissingTerms.length <= this.options.numberOfTerms) {\n            return;\n        }\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n            Core_1.$$(allMissingTerms[index]).hide();\n        }\n        var nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\n        var showMore = Core_1.$$('button', { className: 'coveo-missing-term-show-more coveo-clickable', type: 'button' }, Core_1.l('NMore', [nbMoreResults]));\n        showMore.on('click', function () {\n            _this.showAllHiddenMissingTerms();\n        });\n        elements.push(showMore.el);\n    };\n    MissingTerms.prototype.showAllHiddenMissingTerms = function () {\n        var showMore = Core_1.$$(this.element).find('.coveo-missing-term-show-more');\n        showMore.parentNode.removeChild(showMore);\n        var allMissingTerms = Core_1.$$(this.element).findAll('.coveo-missing-term');\n        for (var index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n            Core_1.$$(allMissingTerms[index]).show();\n            allMissingTerms[index].removeAttribute('style');\n        }\n    };\n    MissingTerms.prototype.isValidTerm = function (term) {\n        return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\n    };\n    MissingTerms.prototype.isValidPhrase = function (phrase, terms) {\n        var _this = this;\n        return terms.every(function (term) {\n            var regex = _this.createWordBoundaryDelimitedRegex(term);\n            var termInPhrase = regex.exec(phrase);\n            return !termInPhrase;\n        });\n    };\n    Object.defineProperty(MissingTerms.prototype, \"breakingCharacters\", {\n        get: function () {\n            return \"[-'?*\\u2019.~=,/\\\\\\\\:`;_!&()]+\";\n        },\n        enumerable: true,\n        configurable: true\n    });\n    MissingTerms.prototype.isNonBoundaryTerm = function (term) {\n        //p{L} is a Unicode script that matches any character in any language.\n        var wordWithBreakpoints = \"\\\\p{L}*\" + this.breakingCharacters + \"\\\\p{L}*\";\n        var regex = XRegExp(wordWithBreakpoints, 'gi');\n        var query = this.queryStateModel.get('q');\n        var matches = query.match(regex) || [];\n        return matches.every(function (word) {\n            return word.indexOf(term) === -1;\n        });\n    };\n    MissingTerms.prototype.logAnalyticsAddMissingTerm = function (term) {\n        this.usageAnalytics.logSearchEvent(AnalyticsActionListMeta_1.analyticsActionCauseList.addMissingTerm, {\n            missingTerm: term\n        });\n    };\n    MissingTerms.ID = 'MissingTerms';\n    /**\n     * @componentOptions\n     */\n    MissingTerms.options = {\n        /**\n         * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\n         *\n         * **Default:** `true`\n         */\n        clickable: ComponentOptions_1.ComponentOptions.buildBooleanOption({ defaultValue: true }),\n        /**\n         * The text to display before missing terms.\n         *\n         * **Default:** The localized string for `Missing`.\n         */\n        caption: ComponentOptions_1.ComponentOptions.buildLocalizedStringOption({\n            localizedString: function () { return Core_1.l('Missing'); }\n        }),\n        /**\n         * The maximum number of missing term to be displayed\n         *\n         * **Default:** `5`\n         * **Minimum value:** `1`\n         */\n        numberOfTerms: ComponentOptions_1.ComponentOptions.buildNumberOption({\n            defaultValue: 5,\n            min: 1\n        })\n    };\n    MissingTerms.doExport = function () {\n        GlobalExports_1.exportGlobally({\n            MissingTerms: MissingTerms\n        });\n    };\n    return MissingTerms;\n}(Component_1.Component));\nexports.MissingTerms = MissingTerms;\nCore_1.Initialization.registerAutoCreateComponent(MissingTerms);\n\n\n/***/ }),\n\n/***/ 698:\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// MissingTerms.min__d6b9bcc2bfcb024de483.js","import 'styling/_MissingTerms';\nimport { $$, Initialization, l } from '../../Core';\nimport { exportGlobally } from '../../GlobalExports';\nimport { IQueryResult } from '../../rest/QueryResult';\nimport { Dom } from '../../utils/Dom';\nimport { analyticsActionCauseList, IAnalyticsMissingTerm } from '../Analytics/AnalyticsActionListMeta';\nimport { Component } from '../Base/Component';\nimport { IComponentBindings } from '../Base/ComponentBindings';\nimport { ComponentOptions } from '../Base/ComponentOptions';\nimport { MissingTermManager } from './MissingTermManager';\nimport XRegExp = require('xregexp');\nimport { intersection } from 'underscore';\nimport { Utils } from '../../UtilsModules';\n\nexport interface IMissingTermsOptions {\n  caption?: string;\n  clickable?: boolean;\n  numberOfTerms?: number;\n}\n\n/**\n * This [result template component](https://docs.coveo.com/en/513/#using-result-template-components) renders a list of query terms\n * that were not matched by the associated result item.\n *\n * @availablesince [July 2019 Release (v2.6459)](https://docs.coveo.com/en/2938/)\n */\nexport class MissingTerms extends Component {\n  static ID = 'MissingTerms';\n\n  /**\n   * @componentOptions\n   */\n  static options: IMissingTermsOptions = {\n    /**\n     * Whether to allow the end-user to click a missing term to filter out items that do not match this term.\n     *\n     * **Default:** `true`\n     */\n    clickable: ComponentOptions.buildBooleanOption({ defaultValue: true }),\n    /**\n     * The text to display before missing terms.\n     *\n     * **Default:** The localized string for `Missing`.\n     */\n    caption: ComponentOptions.buildLocalizedStringOption({\n      localizedString: () => l('Missing')\n    }),\n    /**\n     * The maximum number of missing term to be displayed\n     *\n     * **Default:** `5`\n     * **Minimum value:** `1`\n     */\n    numberOfTerms: ComponentOptions.buildNumberOption({\n      defaultValue: 5,\n      min: 1\n    })\n  };\n\n  static doExport = () => {\n    exportGlobally({\n      MissingTerms: MissingTerms\n    });\n  };\n\n  private termForcedToAppear: string[];\n\n  /**\n   * Creates a new `MissingTerms` component instance.\n   * @param element The element on which to instantiate the component.\n   * @param options The configuration options for the component.\n   * @param bindings The bindings required by the component to function normally. If not set, these will be automatically resolved (with a slower execution time).\n   * @param result The query result item to associate the component with.\n   */\n  constructor(\n    public element: HTMLElement,\n    public options?: IMissingTermsOptions,\n    bindings?: IComponentBindings,\n    public result?: IQueryResult\n  ) {\n    super(element, MissingTerms.ID, bindings);\n\n    this.options = ComponentOptions.initComponentOptions(element, MissingTerms, options);\n    this.addMissingTerms();\n  }\n\n  private get allResultTerms() {\n    let absentTerms = this.result.absentTerms;\n\n    if (this.result.attachments) {\n      absentTerms = this.intersectAbsentTerms(absentTerms, this.result.attachments);\n    }\n\n    if (this.result.childResults) {\n      absentTerms = this.intersectAbsentTerms(absentTerms, this.result.childResults);\n    }\n\n    return absentTerms;\n  }\n\n  private intersectAbsentTerms(absentTerms: string[], results: IQueryResult[]) {\n    return intersection(absentTerms, ...results.map(result => result.absentTerms));\n  }\n\n  /**\n   * Returns all original basic query expression terms and phrases that were not matched by the result item the component instance is associated with.\n   */\n  public get missingTerms() {\n    return [...this.absentTerms, ...this.absentPhrases];\n  }\n\n  private get absentTerms() {\n    const absentTerms: string[] = [];\n    const terms = this.allResultTerms.filter(value => !this.isMissingPhrase(value));\n\n    for (const term of terms) {\n      const termMatch = this.queryMatch(term);\n      termMatch && absentTerms.push(termMatch);\n    }\n\n    return absentTerms;\n  }\n\n  private get absentPhrases() {\n    const absentPhrases: string[] = [];\n    const phrases = this.allResultTerms.filter(value => this.isMissingPhrase(value));\n\n    for (const phrase of phrases) {\n      const withoutQuotes = phrase.slice(1, -1);\n      const phraseMatch = this.queryMatch(withoutQuotes, true);\n      phraseMatch && absentPhrases.push(phraseMatch);\n    }\n\n    return absentPhrases;\n  }\n\n  private isMissingPhrase(value: string) {\n    return Utils.stringStartsWith(value, '\"') && Utils.stringEndsWith(value, '\"');\n  }\n\n  private queryMatch(term: string, stripBreakingCharacters = false): string | null {\n    const regex = this.createWordBoundaryDelimitedRegex(term);\n    const query: string = this.queryStateModel.get('q');\n    // Mimics the query received by the index\n    const queryToExec = stripBreakingCharacters ? query.replace(XRegExp(this.breakingCharacters, 'gi'), ' ') : query;\n    const result = regex.exec(queryToExec);\n\n    if (result) {\n      const originalKeywordInQuery = result[4];\n      return originalKeywordInQuery;\n    }\n\n    return null;\n  }\n\n  /**\n   * Injects a term in the advanced part of the query expression (aq) to filter out items that do not match the term.\n   * @param term The term to add to the advanced query expression.\n   */\n  public addTermForcedToAppear(term: string) {\n    if (this.missingTerms.indexOf(term) === -1) {\n      this.logger.warn(\n        `Method execution aborted because the term to inject in aq (\"${term}\") is not a missing term.`,\n        `Allowed missing terms: ${this.missingTerms.toString()}.`\n      );\n      return;\n    }\n    this.updateTermForcedToAppear();\n    this.termForcedToAppear.push(term);\n    this.queryStateModel.set('missingTerms', [...this.termForcedToAppear]);\n  }\n\n  private updateTermForcedToAppear() {\n    this.termForcedToAppear = [...this.queryStateModel.get('missingTerms')];\n  }\n\n  private addMissingTerms() {\n    if (this.missingTerms.length === 0) {\n      return;\n    }\n    const missingTermElement = this.buildContainer();\n    if (missingTermElement.length > 1) {\n      this.hideMissingTermsOverTheNumberOfResults(missingTermElement);\n      missingTermElement.map(element => {\n        $$(this.element).append(element);\n      });\n    }\n  }\n\n  private buildContainer(): HTMLElement[] {\n    const elements: HTMLElement[] = [];\n    elements.push(this.buildCaption().el);\n    this.buildMissingTerms().forEach(term => {\n      if (term) {\n        elements.push(term.el);\n      }\n    });\n    return elements;\n  }\n\n  private buildCaption(): Dom {\n    return $$('span', { className: 'coveo-field-caption' }, this.options.caption);\n  }\n\n  private buildMissingTerms(): Dom[] {\n    const validTerms = this.absentTerms.filter(term => this.isValidTerm(term));\n    const validPhrases = this.absentPhrases.filter(phrase => this.isValidPhrase(phrase, validTerms));\n    return [...validTerms, ...validPhrases].map(term => {\n      return this.makeTermClickableIfEnabled(term);\n    });\n  }\n\n  private executeNewQuery(missingTerm: string = this.queryStateModel.get('q')) {\n    this.queryController.executeQuery();\n  }\n\n  private makeTermClickableIfEnabled(term: string): Dom {\n    if (this.options.clickable) {\n      const termElement = $$('button', { className: 'coveo-missing-term coveo-clickable', type: 'button' }, term);\n      termElement.on('click', () => {\n        this.addTermForcedToAppear(term);\n        this.logAnalyticsAddMissingTerm(term);\n        this.executeNewQuery(term);\n      });\n      return termElement;\n    } else {\n      return $$('span', { className: 'coveo-missing-term' }, term);\n    }\n  }\n\n  private createWordBoundaryDelimitedRegex(term: string): RegExp {\n    return XRegExp(`${MissingTermManager.wordBoundary}(${term})${MissingTermManager.wordBoundary}`, 'gi');\n  }\n\n  private containsFeaturedResults(term: string): boolean {\n    this.updateTermForcedToAppear();\n    return this.termForcedToAppear.indexOf(term) !== -1;\n  }\n\n  private hideMissingTermsOverTheNumberOfResults(elements: HTMLElement[]) {\n    const allMissingTerms = elements.filter(element => {\n      return element.tagName === 'BUTTON';\n    });\n    if (allMissingTerms.length <= this.options.numberOfTerms) {\n      return;\n    }\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n      $$(allMissingTerms[index]).hide();\n    }\n    const nbMoreResults = allMissingTerms.length - this.options.numberOfTerms;\n    const showMore = $$(\n      'button',\n      { className: 'coveo-missing-term-show-more coveo-clickable', type: 'button' },\n      l('NMore', [nbMoreResults])\n    );\n\n    showMore.on('click', () => {\n      this.showAllHiddenMissingTerms();\n    });\n    elements.push(showMore.el);\n  }\n\n  private showAllHiddenMissingTerms() {\n    const showMore = $$(this.element).find('.coveo-missing-term-show-more');\n    showMore.parentNode.removeChild(showMore);\n    const allMissingTerms = $$(this.element).findAll('.coveo-missing-term');\n    for (let index = this.options.numberOfTerms; index < allMissingTerms.length; index++) {\n      $$(allMissingTerms[index]).show();\n      allMissingTerms[index].removeAttribute('style');\n    }\n  }\n\n  private isValidTerm(term: string) {\n    return this.isNonBoundaryTerm(term) && !this.containsFeaturedResults(term);\n  }\n\n  private isValidPhrase(phrase: string, terms: string[]) {\n    return terms.every(term => {\n      const regex = this.createWordBoundaryDelimitedRegex(term);\n      const termInPhrase = regex.exec(phrase);\n      return !termInPhrase;\n    });\n  }\n\n  private get breakingCharacters() {\n    return `[-'?\\*’.~=,\\/\\\\\\\\:\\`;_!&\\(\\)]+`;\n  }\n\n  private isNonBoundaryTerm(term: string) {\n    //p{L} is a Unicode script that matches any character in any language.\n    const wordWithBreakpoints = `\\\\p{L}*${this.breakingCharacters}\\\\p{L}*`;\n    const regex = XRegExp(wordWithBreakpoints, 'gi');\n    const query = this.queryStateModel.get('q');\n    const matches = query.match(regex) || [];\n    return matches.every((word: string) => {\n      return word.indexOf(term) === -1;\n    });\n  }\n\n  private logAnalyticsAddMissingTerm(term: string) {\n    this.usageAnalytics.logSearchEvent<IAnalyticsMissingTerm>(analyticsActionCauseList.addMissingTerm, {\n      missingTerm: term\n    });\n  }\n}\nInitialization.registerAutoCreateComponent(MissingTerms);\n\n\n\n// WEBPACK FOOTER //\n// ./src/ui/MissingTerm/MissingTerms.ts"],"sourceRoot":""}